<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta http-equiv="X-UA-Compatible" content="ie=edge" />
  <title>To-Do App</title>
  <link rel="stylesheet" href="todo.css" />
</head>

<body>
    <div class="box">
      <!-- Sidebar -->
      <div class="option">
        <div class="opt-head">
        <h2>Categories</h2>
        <button id="closeBtn">
          <svg width="24" height="24" viewBox="0 0 24 24">
            <line x1="4" y1="4" x2="20" y2="20" stroke-width="2" stroke="black" />
            <line x1="20" y1="4" x2="4" y2="20" stroke-width="2" stroke="black" />
          </svg>
        </button>
      </div>
        <ul id="categoryList"></ul>

      
      <button id="addCategoryBtn" class="add-category-btn">+ Add Category</button>
    </div>
      <!-- Header -->
      <div class="flexing">
        <button id="menuBtn">
          <svg width="24" height="24" viewBox="0 0 24 24">
            <rect x="3" y="6" width="18" height="2" fill="white" />
            <rect x="3" y="11" width="18" height="2" fill="white" />
            <rect x="3" y="16" width="18" height="2" fill="white" />
          </svg>
        </button>
  
        <h1>To Do List</h1>
      </div>
  
      <!-- Category label -->
      <p id="currentCategoryLabel" style="color: white; font-style: italic; text-align: center; margin-top: -10px;"></p>
  
      <!-- Input & No-task Message -->
      <div class="container">
        <select id="categoryDropdown" style="display: none; margin-top: 10px;"></select>
        <input id="input" placeholder="Enter a task" />
      
        <button onclick="add()" >Add</button><br>
        
        
      </div>
    </div>
  
    <!-- Task List -->
    <div id="list">
      <ul id="taskList"></ul>
        <p id="noTasksMessage" class="no-tasks"></p>
    </div>
    <script>
const menuBtn = document.getElementById("menuBtn");
const closeBtn = document.getElementById("closeBtn");
const option = document.querySelector(".option");
const input = document.getElementById("input");
const taskList = document.getElementById("taskList");
const currentCategoryLabel = document.getElementById("currentCategoryLabel");
const noTasksMessage = document.getElementById("noTasksMessage");
const categoryList = document.getElementById("categoryList");
const addCategoryBtn = document.getElementById("addCategoryBtn");
const categoryDropdown = document.getElementById("categoryDropdown");

let currentCategory = '';
let tasks = [];
let categories = [];
let db = null;

const DB_NAME = 'TodoAppDB';
const DB_VERSION = 1;
const TASKS_STORE = 'tasks';
const CATEGORIES_STORE = 'categories';

// Initialize IndexedDB
function initDB() {
  return new Promise((resolve, reject) => {
    const request = indexedDB.open(DB_NAME, DB_VERSION);
    
    request.onerror = () => reject(request.error);
    request.onsuccess = () => {
      db = request.result;
      resolve(db);
    };
    
    request.onupgradeneeded = (event) => {
      const database = event.target.result;
      
      // Create tasks store
      if (!database.objectStoreNames.contains(TASKS_STORE)) {
        const tasksStore = database.createObjectStore(TASKS_STORE, { keyPath: 'id' });
        tasksStore.createIndex('category', 'category', { unique: false });
      }
      
      // Create categories store
      if (!database.objectStoreNames.contains(CATEGORIES_STORE)) {
        database.createObjectStore(CATEGORIES_STORE, { keyPath: 'name' });
      }
    };
  });
}

// Save all tasks to IndexedDB
function saveTasks() {
  return new Promise((resolve, reject) => {
    const transaction = db.transaction([TASKS_STORE], 'readwrite');
    const store = transaction.objectStore(TASKS_STORE);
    
    // Clear existing and add all
    store.clear();
    tasks.forEach(task => store.add(task));
    
    transaction.oncomplete = () => resolve();
    transaction.onerror = () => reject(transaction.error);
  });
}

// Load all tasks from IndexedDB
function loadTasks() {
  return new Promise((resolve, reject) => {
    const transaction = db.transaction([TASKS_STORE], 'readonly');
    const store = transaction.objectStore(TASKS_STORE);
    const request = store.getAll();
    
    request.onsuccess = () => resolve(request.result || []);
    request.onerror = () => reject(request.error);
  });
}

// Save all categories to IndexedDB
function saveCategories() {
  return new Promise((resolve, reject) => {
    const transaction = db.transaction([CATEGORIES_STORE], 'readwrite');
    const store = transaction.objectStore(CATEGORIES_STORE);
    
    // Clear existing and add all
    store.clear();
    categories.forEach(cat => store.add({ name: cat }));
    
    transaction.oncomplete = () => resolve();
    transaction.onerror = () => reject(transaction.error);
  });
}

// Load all categories from IndexedDB
function loadCategories() {
  return new Promise((resolve, reject) => {
    const transaction = db.transaction([CATEGORIES_STORE], 'readonly');
    const store = transaction.objectStore(CATEGORIES_STORE);
    const request = store.getAll();
    
    request.onsuccess = () => {
      const result = request.result || [];
      resolve(result.map(c => c.name));
    };
    request.onerror = () => reject(request.error);
  });
}

// Sidebar toggle
menuBtn.addEventListener("click", () => option.classList.add("active"));
closeBtn.addEventListener("click", () => option.classList.remove("active"));

// Create category list item with delete button
function createCategoryElement(categoryName) {
  const li = document.createElement('li');
  li.className = 'category-item';

  const span = document.createElement('span');
  span.textContent = categoryName;

  const deleteBtn = document.createElement('button');
  deleteBtn.textContent = 'ðŸ—‘ï¸';
  deleteBtn.className = 'delete-icon';

  // Click to select category
  span.addEventListener('click', () => {
    document.querySelectorAll('.category-item').forEach(el => el.classList.remove('active'));
    li.classList.add('active');
    currentCategory = categoryName;
    localStorage.setItem('lastCategory', currentCategory);
    renderTasks(currentCategory);
    updatePlaceholder();
    option.classList.remove("active");
  });

  // Click to delete category
  deleteBtn.addEventListener('click', async (e) => {
    e.stopPropagation();

    const confirmed = confirm(`Are you sure you want to delete "${categoryName}" and all its tasks?`);
    if (!confirmed) return;

    // Remove tasks in this category
    tasks = tasks.filter(task => task.category !== categoryName);
    await saveTasks();

    // Remove category from categories array and save
    categories = categories.filter(cat => cat !== categoryName);
    await saveCategories();

    // Remove category from DOM
    li.remove();

    // If currently selected
    if (currentCategory === categoryName) {
      if (categories.length > 0) {
          currentCategory = categories[0];
          localStorage.setItem('lastCategory', currentCategory);
          // Set active class
          document.querySelectorAll('.category-item span').forEach(s => {
            if (s.textContent === currentCategory) {
                s.parentElement.classList.add('active');
            }
          });
      } else {
          currentCategory = '';
          localStorage.removeItem('lastCategory');
      }
      renderTasks(currentCategory);
      updatePlaceholder();
    }
  });

  li.appendChild(span);
  li.appendChild(deleteBtn);
  categoryList.appendChild(li);
}

// Add category button click
addCategoryBtn.addEventListener('click', async () => {
  let newCategory = prompt("Enter new category name:");
  if (!newCategory) return;

  newCategory = newCategory.trim();
  if (newCategory === "") return;

  if (categories.map(cat => cat.toLowerCase()).includes(newCategory.toLowerCase())) {
    alert("This category already exists.");
    return;
  }

  categories.push(newCategory);
  await saveCategories();
  createCategoryElement(newCategory);
});

// Update input placeholder
function updatePlaceholder() {
  if (currentCategory) {
    input.placeholder = `Enter a task in "${currentCategory}"`;
  } else {
    input.placeholder = "Create a category first";
  }
  categoryDropdown.style.display = "none";
}

// Format date for display
function formatDate(timestamp) {
  const date = new Date(timestamp);
  const options = { year: 'numeric', month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit' };
  return date.toLocaleDateString('en-US', options);
}

// Add task
async function add() {
  const text = input.value.trim();
  if (text === "") return;

  if (!currentCategory) {
      alert("Please create a category first.");
      return;
  }

  await addTask(text, currentCategory);
  input.value = "";
}

async function addTask(taskText, category) {
  const task = {
    id: Date.now(),
    text: taskText,
    completed: false,
    category: category,
    createdAt: Date.now()
  };
  tasks.push(task);
  await saveTasks();
  renderTasks(currentCategory);
}

async function deleteTask(id) {
  tasks = tasks.filter(task => task.id !== id);
  await saveTasks();
  renderTasks(currentCategory);
}

async function toggleTask(id) {
  tasks = tasks.map(task =>
    task.id === id ? { ...task, completed: !task.completed } : task
  );
  await saveTasks();
  renderTasks(currentCategory);
}

function renderTasks(category) {
  taskList.innerHTML = '';
  
  if (!category) {
      currentCategoryLabel.textContent = "No Category Selected";
      noTasksMessage.textContent = "Create a category to get started.";
      return;
  }
  
  currentCategoryLabel.textContent = `Viewing: ${category}`;

  const filteredTasks = tasks.filter(task => task.category === category);

  if (filteredTasks.length === 0) {
    noTasksMessage.textContent = `No tasks in "${category}"`;
    return;
  }

  noTasksMessage.textContent = '';

  filteredTasks.forEach(task => {
    if (!task.text || task.text.trim() === "") return;

    const li = document.createElement('li');
    li.setAttribute("class", "listings");
    li.style.backgroundColor = "#dbceff";
    li.style.padding = "10px";
    li.style.marginBottom = "8px";
    li.style.borderRadius = "5px";
    li.style.cursor = "grab";
    li.style.display = "flex";
    li.style.flexDirection = "column";

    // First line container (checkbox + task text + badge)
    const topLine = document.createElement('div');
    topLine.style.display = 'flex';
    topLine.style.justifyContent = 'space-between';
    topLine.style.alignItems = 'center';
    topLine.style.gap="10px";

    // Left side: checkbox + text
    const leftSide = document.createElement('div');
    leftSide.style.display = 'flex';
    leftSide.style.alignItems = 'center';
    leftSide.style.flex = '1';

    // Checkbox for marking complete
    const checkbox = document.createElement('input');
    checkbox.type = 'checkbox';
    checkbox.checked = task.completed;
    checkbox.style.marginRight = '10px';
    checkbox.style.cursor = 'pointer';
    checkbox.style.width = '18px';
    checkbox.style.height = '18px';
    checkbox.addEventListener('change', () => toggleTask(task.id));

    // Task text span
    const taskTextSpan = document.createElement('span');
    taskTextSpan.textContent = task.text;
    if (task.completed) {
      taskTextSpan.style.textDecoration = 'line-through';
      taskTextSpan.style.color = '#888';
    }
    taskTextSpan.style.cursor = 'pointer';
    taskTextSpan.title = "Click to toggle complete";

    taskTextSpan.addEventListener('click', () => toggleTask(task.id));

    leftSide.appendChild(checkbox);
    leftSide.appendChild(taskTextSpan);
    topLine.appendChild(leftSide);

    // Category badge tag
    const categoryTag = document.createElement('span');
    categoryTag.textContent = task.category;
    categoryTag.className = 'category-tag';

    // Safe class for category color
    const safeCategoryClass = 'category-' + task.category.replace(/\s+/g, '-').replace(/[^\w-]/g, '');
    categoryTag.classList.add(safeCategoryClass);

    topLine.appendChild(categoryTag);

    li.appendChild(topLine);

    // Date line
    const dateLine = document.createElement('div');
    dateLine.style.fontSize = '12px';
    dateLine.style.color = '#666';
    dateLine.style.marginTop = '6px';
    dateLine.textContent = 'Created: ' + formatDate(task.createdAt || task.id);
    li.appendChild(dateLine);

    // Second line for buttons
    const btnLine = document.createElement('div');
    btnLine.style.marginTop = '6px';

    // Edit button
    const editBtn = document.createElement('button');
    editBtn.textContent = 'Edit';
    editBtn.style.backgroundColor = "green";
    editBtn.style.color = 'white';
    editBtn.style.marginRight = '10px';
    editBtn.style.cursor = 'pointer';
    editBtn.onclick = (e) => {
      e.stopPropagation();
      editTask(task, taskTextSpan);
    };

    // Delete button
    const delBtn = document.createElement('button');
    delBtn.textContent = 'Delete';
    delBtn.style.cursor = 'pointer';
    delBtn.onclick = (e) => {
      e.stopPropagation();
      deleteTask(task.id);
    };

    btnLine.appendChild(editBtn);
    btnLine.appendChild(delBtn);

    li.appendChild(btnLine);

    // Drag & drop attributes and handlers
    li.draggable = true;
    li.dataset.id = task.id;

    li.addEventListener('dragstart', dragStart);
    li.addEventListener('dragover', dragOver);
    li.addEventListener('drop', drop);
    li.addEventListener('dragend', dragEnd);

    taskList.appendChild(li);
  });
}

// Edit task function
function editTask(task, taskTextSpan) {
  const inputEl = document.createElement('input');
  inputEl.type = 'text';
  inputEl.value = task.text;
  inputEl.style.width = '70%';

  // Replace the span with the input field
  taskTextSpan.replaceWith(inputEl);
  inputEl.focus();

  // Save edit on Enter or blur
  async function saveEdit() {
    const newText = inputEl.value.trim();
    if (newText === "") {
      alert("Task cannot be empty!");
      inputEl.focus();
      return;
    }

    // If text changed, update tasks array and save
    if (newText !== task.text) {
      tasks = tasks.map(t => t.id === task.id ? { ...t, text: newText } : t);
      await saveTasks();
      renderTasks(currentCategory);
    } else {
      // If no changes, just render again
      renderTasks(currentCategory);
    }
  }

  inputEl.addEventListener('keydown', (e) => {
    if (e.key === 'Enter') {
      saveEdit();
    } else if (e.key === 'Escape') {
      // Cancel edit on Escape
      renderTasks(currentCategory);
    }
  });

  inputEl.addEventListener('blur', () => {
    saveEdit();
  });
}

// Drag & Drop handlers
let draggedItem = null;

function dragStart(e) {
  draggedItem = e.currentTarget;
  e.dataTransfer.effectAllowed = 'move';
  setTimeout(() => {
    draggedItem.style.display = 'none';
  }, 0);
}

function dragOver(e) {
  e.preventDefault();
  const target = e.currentTarget;
  if (target && target !== draggedItem && target.parentNode === draggedItem.parentNode) {
    const bounding = target.getBoundingClientRect();
    const offset = e.clientY - bounding.top;
    if (offset > bounding.height / 2) {
      target.style['border-bottom'] = 'solid 2px #555';
      target.style['border-top'] = '';
    } else {
      target.style['border-top'] = 'solid 2px #555';
      target.style['border-bottom'] = '';
    }
  }
}

function drop(e) {
  e.preventDefault();
  const target = e.currentTarget;
  if (target && target !== draggedItem && target.parentNode === draggedItem.parentNode) {
    const bounding = target.getBoundingClientRect();
    const offset = e.clientY - bounding.top;
    if (offset > bounding.height / 2) {
      target.style['border-bottom'] = '';
      target.parentNode.insertBefore(draggedItem, target.nextSibling);
    } else {
      target.style['border-top'] = '';
      target.parentNode.insertBefore(draggedItem, target);
    }

    updateTasksOrder();
  }
}

function dragEnd(e) {
  e.currentTarget.style.display = 'block';
  document.querySelectorAll('#taskList li').forEach(li => {
    li.style['border-top'] = '';
    li.style['border-bottom'] = '';
  });
  draggedItem = null;
}

async function updateTasksOrder() {
  const updatedTasks = [];
  document.querySelectorAll('#taskList li').forEach(li => {
    const id = parseInt(li.dataset.id);
    const task = tasks.find(t => t.id === id);
    if (task) updatedTasks.push(task);
  });
  tasks = updatedTasks;
  await saveTasks();
}

// Initialize app
async function initApp() {
  try {
    await initDB();
    
    // Load categories
    categories = await loadCategories();
    if (categories.length === 0) {
      categories = ["Personal", "Work"]; 
      await saveCategories();
    }
    
    // Load tasks
    tasks = await loadTasks();
    
    // Create category elements
    categories.forEach(category => createCategoryElement(category));
    
    // Restore last active category
    const lastCategory = localStorage.getItem('lastCategory');
    if (lastCategory && categories.includes(lastCategory)) {
        currentCategory = lastCategory;
    } else if (categories.length > 0) {
        currentCategory = categories[0];
    } else {
        currentCategory = '';
    }
    
    // Set active class
    if (currentCategory) {
        localStorage.setItem('lastCategory', currentCategory);
        document.querySelectorAll('.category-item span').forEach(span => {
            if (span.textContent === currentCategory) {
                span.parentElement.classList.add('active');
            }
        });
    }
    
    updatePlaceholder();
    renderTasks(currentCategory);
  } catch (error) {
    console.error('Failed to initialize app:', error);
    alert('Failed to initialize database. Please refresh the page.');
  }
}

// Start the app
initApp();
    </script>
      
    
</body>
</html>

